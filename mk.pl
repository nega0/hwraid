#!/usr/bin/env perl # -*- mode: cperl; indent-tabs-mode: nil; cperl-indent-level: 4 -*-

use Smart::Comments;
use feature qw(say state);
use warnings;
use strict;
use utf8;

## #######
## This is the header of our generated file. It contains local
## variables for both vim and Emacs to enable folding. Emacs folding
## requires the external library 'folding.el'.

print <<__end_of_header;
#!/usr/bin/env perl # -*- mode: cperl; folded-file: t; indent-tabs-mode: nil; cperl-indent-level: 4 -*-
# vim: foldmethod=marker

## This file is automatically generated from $0 Any edits should be
## made there. The intent of this file is to fake calls "megacli" for
## the offline testing of "megaclisas-status"

use feature qw(say);
use warnings;
use strict;
use utf8;

use Getopt::Long;

# {{{ this fold contains our data

__end_of_header
  ;

## #######
## This is primary loop where "megacli" commands are read in from
## stdin and executed. Output is trimmed, and output to stdout as part
## of a heredoc in the generated file. The heredoc is wrapped in
## vim/emacs folding marks. TODO: de-duplicate calls to "megacli"

my $argmap = {};
my $args = {};

while (<>) {
    chomp;
    state $i = 0;

    my $e =qx/ sudo $_ /;
    $e =~ s/^\s+|\s+$//g;	# trim whitespace
    say <<"__end_of_line";
# {{{ $_
my \$out_$i = <<__end_of_output;
$e
__end_of_output
# }}}

__end_of_line

    ## #######
    ## here we build two hash refs. the first, in argmap is a hash of
    ## arrays associating the heredoc we just built/wrote with the
    ## "megacli" arguments used to generate it. working inside-out, we
    ## split line input on whitespace, take the array-ref of the
    ## output, dereference it, use splice to drop the 1st element,
    ## then assign the remainder of the list to its associated heredoc
    ## label. next we take the elements of the hash entry we just
    ## created and add them as keys to the hash-ref $args. at the end
    ## of this primary loop, $args will effectively be a
    ## list-of-unique-elements 
    $argmap->{"out_$i"} = [ splice @{[ split(/\s+/, $_) ]}, 1 ];
    foreach my $e (@{$argmap->{"out_$i"}}) {
        $args->{substr($e,1)} = '';
    }
    
    ++$i;
}
say "# }}}\n"; # closing fold mark that matches the open mark in the header


## #######
## set up Getopt::Long. declare the options variables we'll use in
## GetOptions(). @ARGV/$#ARGV is destroyed by GetOptions() so we grab
## the count now and increment, because $#ARGV is always 1 less than
## the number of arguments

foreach my $key (sort keys %$args) {
    say "my \$$key;";
}

say "";
say 'my $arg_count = $#ARGV + 1;';
say 'GetOptions(';
foreach my $key (sort keys %$args) {
    say "    \"$key\", \\\$$key,";
}
say ");\n";

## #######
## build our switch/cascade-of-ifs. tests are argument count and
## arguments given to the generated file. if nothing matches exit with
## an error

foreach my $key (sort {substr($a,4) <=> substr($b,4)} keys %$argmap) {
    print "if (\$arg_count == ", scalar(@{$argmap->{$key}}), " && ";
    print join " && ", map { $_ =~ s/^-/\$/; $_ } @{$argmap->{$key}};
    print ") {\n";
    print "    say \$$key;\n";
    print "    exit;\n";
    print "}\n\n";
}

say "Unknown combination of arguments";
say "exit(1);";
